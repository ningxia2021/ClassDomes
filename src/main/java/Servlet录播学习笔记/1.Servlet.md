# Servlet 2022.04.13
+ Servlet是啥？
    它是实现动态页面的技术，更准确的说 它是Tomcat提供的 API ,帮助程序员高效开发 webApp。即 Tomcat API = Servlet
+ 基于 Servlet 开发
    1. 初始化, 允许程序员注册一个类到Tomcat中，让这个类和HTTP中的一个特定的请求相关联。（类似于 js 给按钮关联一个事件）
    2. 进入循环（循环处理请求）
        a. 读取HTTP请求，Servlet解析这个请求字符串，生成一个HttpServletRequest对象
        b. 根据请求对象生成一个HttpServletResponse对象（表示相应）
        c. 把HttpServletResponse 对象转化成HTTP响应，返回给浏览器
        这其中 1 2.a 2.c Tomcat/Servlet 都已经帮我们实现了，程序员只需要关注a.b这个环节 （业务逻辑）
+ **[创建一个Servlet项目]**
    1. new project 选择 maven ，然后一路next
    2. 引入依赖 ~引入 Servlet api的 jar包
    3. 创建目录和文件 
        a. 在 main 目录下创建 一个新的目录 webapp
        b. 在 webapp 目录下创建 新目录 WEB-INF
        c. 在 WEB-INF 下创建文件 web.xml
        d. 在 web.xml 中写入一下内容:
            <web-app>
                <display-name>Archetype Created web Application</display-name>
            </web-app>
    4. 编写代码
        a. 创建一个类 继承HttpServlet
        b. 重写doGet doPost 方法
        c. 在方法里面根据请求计算响应
        d. 给类上加注解 把 类 和一个具体的 Http 请求的路径关联起来
        e. 路径一致->调用这个类的代码->请求是GET 就调用代码中的doGet方法。      
    5. 打包程序 即，把项目代码进行编译，打一个压缩包出来
        a. 基于maven来进行打包
             右边栏打开maven->选择lifecycle->双击package 即可开始打包。
             打包完成后会有 [INFO] BUILD SUCCESS 字样
             target 目录中 就包含了我们刚才打好的 jar 包 
        b. jar 包 和 war 包的区别
             jar包是普通的java程序打的包(java -jar),里面会包含一些.class文件
             war包是java web的程序，里面除了.class文件还会包含HTML CSS Js 图片 其他jar包
             Tomcat 不能直接识别 jar 格式的包，应该打成 war 格式的包
        c. 因此，需要修改maven中 pom.xml 的配置，修改打包类型为 war
             进入pom.xml 添加一下信息,
             <!--  修改打包信息  -->
             <packaging>war</packaging>
        d. 重新打包 测试
        e. war 包重命名
             后面通过浏览器 URL 访问这个webapp时，要在 URL 中带上这个目录的名字，因此，尽量换个简单的名字。
             当前的名字是 artifactId+version 拼接出来的。
             具体通过修改pom.xml来实现:
             <!--  对war包重命名  -->
              <build>
                <finalName>javaServlet01</finalName> (在build的最外层加)
              </build>
        f. 部署程序
             把 war 包拷贝到 Tomcat 的 webapp 的目录中即可
             随着 Tomcat 启动，这个war包就会自动解压缩成为一个 同名目录
             同名目录包含: WEB-INF 包含了 web.xml 以及编译后生成的 .class文件 
                         META-INF 包含了 运行程序依赖的一些第三方jar包
        g. 验证程序是否正确
             通过浏览器访问 Tomcat，构造特定请求，触发 HelloServlet 代码
             具体实现:
                http://127.0.0.1:8080/webapp中war包解压后同名目录的名字，通过这一级路径就定位到一个具体的webapp了/代码中 WebServlet('/hello') 的注解，触发HelloServlet代码
                http://127.0.0.1:8080/javaServlet01/hello
             页面显示
                Hello Servlet
        h. 以上步骤还可通过Smart Tomcat插件来简化 打包 + 部署！spring 也会对这些过程简化! 但是不能忘记Servlet的开发过程！
+ **[Smart Tomcat插件]**
    插件 plugin ，像是软件一样，用到就安装，不用就卸载.
    IDEA 专业版 自带Tomcat部署功能，不需要使用Smart Tomcat.
    IDEA 社区版 没有自带，才需要使用Smart Tomcat.
    配置过程:
        File->Project Structure->Modules 右键已有模块，Add->Web
        添加完成后，发现他提示说’Web’并不包含在任何Artifacts中，于是我们点击create Artifact去创建一个Artifact
        这里还需要:修改Deployment Descriptors中Path ,路径要到Web\WEB-INF\web.xml
                 修改Web Resource Directories ，路径到Web即可
                 修改Source Roots ，选中代码所在的蓝色根目录
                 另外，主页html文件需放入Web下第一层
        接下来就是在Run->Edit Configurations 中添加Tomcat local，如果上面的配置没有问题，这一块基本上有手就可以，不再赘述！
---
+ 一些常见问题
    [404] 最大的原因就是 URL 路径写错了
    [405] 请求的方法和代码中重写的方法对不上号 
    [500] 代码中抛异常了，页面上或者Tomcat日志里会明确提示异常的调用栈等详细信息
    [空白] xx extends HttpServlet中 doGet方法没有写body
    [无法访问此网站] Tomcat 启动失败  Servlet中<url pattern>无效,即注解中的路径有问题
---
+ **[Tomcat 初始化流程]**
    1. 解析所有被注解 @WebServlet('/xxx') 修饰的类，并进行类加载
    2. 实例化这些 被注解 @WebServlet('/xxx') 修饰的类
    3. 实例有了之后，会依次调用每个实例的 init() 方法
    4. 启动 HTTP 服务器，绑定端口号
    5. 创建线程池
    6. 循环调用 socket.accept(); 并给每个建立连接的socket分配线程开始工作 
        pool.execute(new Runnable(){
            doHttpRequest(socket);
            });
    7. 最后依次调用每个 servlet.destroy() 
+ **[Tomcat 处理请求流程]**
    1. 具体就是 doHttpRequest(socket) 的实现过程;
    2. 进行HTTP协议请求解析和响应构建
        HttpServletRequest req = HttpServletRequest.parse(socket);
        HttpServletResponse resp = HttpServletResponse.build(socket);
    3. 判断当前url中的路径是否是静态文件
        if(file.exists()){
            返回静态文件
            return;
        }
    4. 如果不是静态文件，则将对动态文件进行操作,找到当前需要操作的Servlet对象
        URL->注解->类
        Servlet ins = findInstance(req.getURL());
    5. 调用 Servlet 对象的 service 方法，
        ins.service(req,resp);
    6. service 里面会根据请求的方法判断要调用的方法
        public void service(HttpServletRequest req,HttpServletResponse resp){
            String methods = req.getMethod();
            if(methods.equals("GET")){
                doGet(req,resp);            
            }else if(methods.equals("POST")){
                doPost(req,resp);            
            }else if(methods.equals("PUT")){
                doPut(req,resp);            
            }
            ...
        }
        这里会触发多态，调用到我们自己重写的doGet方法
+ Servlet 生命周期
    1.Servlet 实例化之后调用一次init()
    2.Servlet 每次收到请求，调用一次service()
    3.Servlet 销毁之前调用一次destroy()
+ **[Servlet 核心掌握三个类]**
    [HttpServlet] 创建类并继承HttpServlet，是为了能够重写它的一些方法;
                  重写方法的目的是为了把程序员定义的逻辑插入到 Tomcat 这个框架中！让 Tomcat 能够进行调用，此处使用多态来进行的。
    [HttpServletRequest] 表示一个 Http 请求，理解这个类的前提就是理解HTTP协议的格式
                          HTTP请求报文：
                          1. 首行 (方法 URL(path, query string) 版本号)
                          2. header (一堆键值对 cookie等)
                          3. 空行
                          4. body
                          Tomcat 会根据 HTTP 协议请求格式把字符串结构的请求 解析成一个结构化的数据(结构化数据相当于一个类，它的属性就是这些字符串中我们需要的数据，可以通过get set方法访问他们) 
                          这个类中的方法可以获得 HTTP 请求中的各个方面的信息
    [HttpServletResponse] 
    
        
    
    
    